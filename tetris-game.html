<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tetris | Classic Puzzle Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>

    <!-- Google Fonts for Tetris and general synthwave vibe -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* Tetris Specific CSS Variables (keep these) */
        :root {
            --color-bg: #000000; /* Changed to Black */
            --color-grid: #8B0000; /* Changed to Dark Red */
            --color-border: #FF4444; /* Changed to Brighter Red */
            --color-text: #E0F7FA; /* Changed to Neon White (light cyan-white) */
            --color-accent: #39FF14; /* Changed to Neon Green */
            --color-i: #00f0f0;
            --color-o: #f0f000;
            --color-t: #a000f0;
            --color-s: #00f000;
            --color-z: #f00000;
            --color-j: #0000f0;
            --color-l: #f0a000;
        }

        /* --- NEW: VIDEO BACKGROUND CSS --- */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            /* Fallback image if video fails to load or play */
            background-image: url('fallback.jpg'); /* Ensure you have 'fallback.jpg' in the same directory */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #000; /* Solid background if even fallback image fails */
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4); /* Semi-transparent black */
            z-index: 0; /* Between video and game content */
        }
        /* --- END NEW: VIDEO BACKGROUND CSS --- */


        /* --- TETRIS GAME SPECIFIC CSS --- */
        body {
            font-family: 'Press Start 2P', cursive; /* Main game font */
            background-color: transparent; /* Changed to transparent to reveal video */
            color: var(--color-text); /* Now neon white */
            min-height: 100vh;
            position: relative; /* Establishes a stacking context for main content relative to fixed background */
            /* The 'flex flex-col' class in the HTML handles the main layout */
        }

        /* NEW: Fade-in animation for the entire game content on load */
        .fade-in-on-load {
            opacity: 0; /* Start invisible */
            animation: fadeIn 1s ease-out forwards; /* Apply fade-in animation, keep end state */
            animation-delay: 0.2s; /* Optional: slight delay to allow page to render before fading */
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tetris-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 1px;
            background-color: var(--color-grid); /* Now dark red */
            border: 4px solid var(--color-border); /* Now brighter red */
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.2); /* Red glow for the grid */
        }

        .cell {
            aspect-ratio: 1/1;
            background-color: var(--color-grid); /* Now dark red */
            transition: all 0.1s ease;
        }

        .tetromino {
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: inset 0 0 8px rgba(255,255,255,0.2);
        }

        .I { background-color: var(--color-i); }
        .O { background-color: var(--color-o); }
        .T { background-color: var(--color-t); }
        .S { background-color: var(--color-s); }
        .Z { background-color: var(--color-z); }
        .J { background-color: var(--color-j); }
        .L { background-color: var(--color-l); }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 1px;
            background-color: var(--color-grid); /* Now dark red */
            border: 2px solid var(--color-border); /* Now brighter red */
        }

        .glow-text {
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.7); /* Neon green glow */
        }

        /* Custom class for neon green text */
        .text-neon-green {
            color: var(--color-accent);
        }

        .btn-neon {
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.5); /* Neon green glow */
            position: relative;
            overflow: hidden;
        }

        .btn-neon:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.8); /* Neon green glow */
        }

        .btn-neon:active {
            transform: translateY(0);
        }

        .btn-neon::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(255, 255, 255, 0.3),
                rgba(255, 255, 255, 0)
            );
            transform: rotate(30deg);
            transition: all 0.3s;
            opacity: 0;
        }

        .btn-neon:hover::before {
            opacity: 1;
            animation: shine 1.5s infinite;
        }

        @keyframes shine {
            0% { left: -50%; }
            100% { left: 150%; }
        }

        .panel {
            background-color: rgba(139, 0, 0, 0.4); /* Dark red translucent */
            border: 1px solid var(--color-border); /* Now brighter red */
            backdrop-filter: blur(5px);
            border-radius: 0.75rem;
            transition: all 0.3s ease;
        }

        .panel:hover {
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.3); /* Neon green glow */
        }

        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Ensures modal is on top of everything */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .game-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .game-modal {
            background-color: var(--color-bg); /* Now black */
            border: 2px solid var(--color-accent); /* Now neon green */
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.5); /* Neon green glow */
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        .game-overlay.active .game-modal {
            transform: scale(1);
        }

        .score-bubble {
            position: relative;
            display: inline-block;
            padding: 0.5rem 1rem;
            background-color: var(--color-text); /* Changed to neon white */
            color: var(--color-bg); /* Text color remains black for contrast */
            border-radius: 9999px;
            font-weight: bold;
            margin: 0.5rem 0;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.5); /* Neon green glow */
        }

        .line-clear {
            position: absolute;
            width: 100%;
            height: 1px;
            background-color: white;
            opacity: 0;
            animation: lineClear 0.5s ease-out;
        }

        @keyframes lineClear {
            0% { opacity: 0; transform: scaleX(0); }
            50% { opacity: 1; transform: scaleX(1); }
            100% { opacity: 0; transform: scaleX(0); }
        }

        .tetromino-fall {
            animation: tetrominoFall 0.1s ease-out;
        }

        @keyframes tetrominoFall {
            0% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }
    </style>
</head>
<body class="flex flex-col fade-in-on-load"> <!-- ADDED: fade-in-on-load class here -->
    <!-- NEW: Video background container -->
    <video class="video-background" autoplay muted loop playsinline>
        <source src="video.mp4" type="video/mp4">
        <source src="video.webm" type="video/webm">
        <source src="video.ogv" type="video/ogg">
        Your browser does not support the video tag.
    </video>

    <!-- NEW: Optional dark overlay for better text readability -->
    <div class="overlay"></div>
    <!-- END NEW -->

    <header class="py-6 px-4 text-center relative">
        <h1 class="text-4xl md:text-5xl glow-text text-neon-green mb-2" data-aos="fade-down">NEON TETRIS</h1>
        <p class="text-xs md:text-sm text-slate-300" data-aos="fade-up">The ultimate puzzle challenge</p>

        <!-- OLD Mute/Unmute Button removed from here -->
    </header>

    <main class="flex-1 container mx-auto px-4 py-4 flex flex-col lg:flex-row items-center justify-center gap-8">
        <!-- Game Area -->
        <div class="flex flex-col items-center" data-aos="fade-right">
            <div class="relative">
                <div class="tetris-grid w-full max-w-xs h-[500px] mb-6" id="game-grid"></div>
                <div class="absolute inset-0 flex items-center justify-center hidden" id="pause-overlay">
                    <div class="bg-black bg-opacity-70 p-4 rounded-lg text-white text-xl">
                        PAUSED
                    </div>
                </div>
            </div>
            <div class="flex gap-4 mt-2">
                <button class="btn-neon bg-emerald-600 hover:bg-emerald-500 text-white px-6 py-2 rounded-lg flex items-center" id="start-btn">
                    <i data-feather="play" class="mr-2"></i>Start
                </button>
                <button class="btn-neon bg-red-700 hover:bg-red-600 text-white px-6 py-2 rounded-lg flex items-center" id="pause-btn" disabled>
                    <i data-feather="pause" class="mr-2"></i>Pause
                </button>
                <button class="btn-neon bg-red-700 hover:bg-red-600 text-white px-6 py-2 rounded-lg flex items-center" id="reset-btn">
                    <i data-feather="refresh-cw" class="mr-2"></i>Reset
                </button>
            </div>
            <!-- NEW: Music Button placed in a new row below the other control buttons -->
            <div class="flex justify-center mt-4 w-full">
                <button class="btn-neon bg-blue-700 hover:bg-blue-600 text-white px-6 py-2 rounded-lg flex items-center" id="music-toggle-btn">
                    <i data-feather="volume-2" class="mr-2"></i>Music
                </button>
            </div>
        </div>

        <!-- Game Info -->
        <div class="w-full max-w-xs space-y-6" data-aos="fade-left">
            <div class="panel p-6">
                <h2 class="text-xl text-neon-green mb-4 flex items-center">
                    <i data-feather="activity" class="mr-2"></i>Game Stats
                </h2>
                <div class="space-y-4">
                    <div>
                        <p class="text-xs text-slate-400">SCORE</p>
                        <p class="text-2xl font-mono" id="score">0</p>
                    </div>
                    <div>
                        <p class="text-xs text-slate-400">LEVEL</p>
                        <p class="text-2xl font-mono" id="level">1</p>
                    </div>
                    <div>
                        <p class="text-xs text-slate-400">LINES</p>
                        <p class="text-2xl font-mono" id="lines">0</p>
                    </div>
                </div>
            </div>

            <div class="panel p-6">
                <h2 class="text-xl text-neon-green mb-4 flex items-center">
                    <i data-feather="chevrons-right" class="mr-2"></i>Next Piece
                </h2>
                <div class="preview-grid w-24 h-24 mx-auto" id="next-piece"></div>
            </div>

            <div class="panel p-6">
                <h2 class="text-xl text-neon-green mb-4 flex items-center">
                    <i data-feather="command" class="mr-2"></i>Controls
                </h2>
                <ul class="text-xs space-y-2">
                    <li class="flex items-center"><i data-feather="arrow-left" class="mr-2 w-4 h-4"></i> A / &larr; Move Left</li>
                    <li class="flex items-center"><i data-feather="arrow-right" class="mr-2 w-4 h-4"></i> D / &rarr; Move Right</li>
                    <li class="flex items-center"><i data-feather="arrow-down" class="mr-2 w-4 h-4"></i> S / &darr; Soft Drop</li>
                    <li class="flex items-center"><i data-feather="arrow-up" class="mr-2 w-4 h-4"></i> W / &uarr; Rotate</li>
                    <li class="flex items-center"><i data-feather="space" class="mr-2 w-4 h-4"></i> Space: Hard Drop</li>
                    <li class="flex items-center"><i data-feather="pause" class="mr-2 w-4 h-4"></i> P: Pause</li>
                    <li class="flex items-center"><i data-feather="refresh-cw" class="mr-2 w-4 h-4"></i> R: Reset Game</li>
                    <li class="flex items-center"><i data-feather="corner-down-left" class="mr-2 w-4 h-4"></i> Enter: Start/Resume</li>
                    <li class="flex items-center"><i data-feather="volume-2" class="mr-2 w-4 h-4"></i> M: Music Toggle</li> <!-- ADDED new control instruction -->
                </ul>
            </div>

            <!-- NEW: High Scores Panel -->
            <div class="panel p-6">
                <h2 class="text-xl text-neon-green mb-4 flex items-center">
                    <i data-feather="award" class="mr-2"></i>High Scores
                </h2>
                <ul id="high-scores-list" class="text-sm space-y-2">
                    <li class="flex justify-between">
                        <span>No scores yet.</span>
                    </li>
                </ul>
            </div>
            <!-- END NEW -->

        </div>
    </main>

    <div class="game-overlay" id="game-over-modal">
        <div class="game-modal">
            <h2 class="text-2xl text-neon-green mb-4">GAME OVER!</h2>
            <div class="score-bubble" id="final-score">0</div>
            <div class="mt-4">
                <input type="text" id="player-name" placeholder="Enter your name"
                       class="bg-slate-800 text-white p-3 rounded-lg w-full mb-4 text-center"
                       maxlength="10">
                <div class="flex gap-2">
                    <button class="btn-neon bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded-lg flex-1 flex items-center justify-center" id="save-score">
                        <i data-feather="save" class="mr-2"></i>Save
                    </button>
                    <button class="btn-neon bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded-lg flex-1 flex items-center justify-center" id="play-again">
                        <i data-feather="play" class="mr-2"></i>Play Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <footer class="py-6 px-4 text-center text-xs text-slate-500">
        <p>Â© 2025 Neon Tetris | All rights reserved</p>
    </footer>

    <!-- NEW: Background music audio element -->
    <audio id="background-music" loop>
        <source src="tetris-theme.mp3" type="audio/mpeg">
        <source src="tetris-theme.ogg" type="audio/ogg"> <!-- Optional: for broader compatibility -->
        Your browser does not support the audio element.
    </audio>
    <!-- END NEW -->

    <script>
        // Initialize AOS animations for scroll effects
        AOS.init({
            duration: 800,
            once: true
        });

        // Initialize Feather Icons
        feather.replace(); // This initial call replaces all <i> with <svg>

        // Game Configuration
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 20;
        const BLOCK_SIZE = 30; // Not directly used in current CSS, but good to keep
        const INITIAL_SPEED = 1000;
        const SPEED_DECREMENT = 50;
        const MIN_SPEED = 100;
        const LINES_PER_LEVEL = 10;
        const SCORE_VALUES = [0, 100, 300, 500, 800]; // Points for 0, 1, 2, 3, 4 lines cleared

        // Game State
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameInterval;
        let isPaused = false;
        let gameStarted = false;
        let grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
        let currentPiece = {
            shape: null,
            type: null,
            position: { x: 0, y: 0 }
        };
        let nextPieceType = null;

        // DOM Elements
        const gameGrid = document.getElementById('game-grid');
        const nextPieceGrid = document.getElementById('next-piece');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const pauseOverlay = document.getElementById('pause-overlay');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreElement = document.getElementById('final-score');
        const playerNameInput = document.getElementById('player-name');
        const saveScoreBtn = document.getElementById('save-score');
        const playAgainBtn = document.getElementById('play-again');
        const highScoresList = document.getElementById('high-scores-list'); // NEW: High scores list element

        // NEW: Music Elements and State
        const bgMusic = document.getElementById('background-music');
        // MODIFIED: Reference the new button ID for music toggle
        const muteToggleBtn = document.getElementById('music-toggle-btn');
        let isMusicMuted = false; // Initial state, will be loaded from localStorage

        // Tetromino Shapes
        const SHAPES = {
            I: [ // Cyan
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            O: [ // Yellow
                [1, 1],
                [1, 1]
            ],
            T: [ // Purple
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            S: [ // Green
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0]
            ],
            Z: [ // Red
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0]
            ],
            J: [ // Blue
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            L: [ // Orange
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ]
        };

        /**
         * Initializes the main game grid visually in the HTML.
         */
        function initGrid() {
            gameGrid.innerHTML = '';
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${y}-${x}`;
                    gameGrid.appendChild(cell);
                }
            }
        }

        /**
         * Initializes the next piece preview grid visually in the HTML.
         */
        function initNextPieceGrid() {
            nextPieceGrid.innerHTML = '';
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `next-cell-${y}-${x}`;
                    nextPieceGrid.appendChild(cell);
                }
            }
        }

        /**
         * Returns a random tetromino type (e.g., 'I', 'J', 'L').
         * @returns {string} The type of the random tetromino.
         */
        function getRandomPieceType() {
            const pieces = Object.keys(SHAPES);
            return pieces[Math.floor(Math.random() * pieces.length)];
        }

        /**
         * Creates a new current piece and sets the next piece.
         */
        function createNewPiece() {
            // The current piece becomes the previously generated "next piece"
            currentPiece.type = nextPieceType;
            currentPiece.shape = SHAPES[currentPiece.type];
            currentPiece.position = {
                x: Math.floor(GRID_WIDTH / 2) - Math.floor(currentPiece.shape[0].length / 2), // Center horizontally
                y: 0 // Start at the top
            };

            // Generate a new "next piece" for the preview
            nextPieceType = getRandomPieceType();
            updateNextPiecePreview();
        }

        /**
         * Updates the visual display of the next tetromino piece.
         */
        function updateNextPiecePreview() {
            const nextShape = SHAPES[nextPieceType];

            // Clear the preview grid
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    const cell = document.getElementById(`next-cell-${y}-${x}`);
                    cell.className = 'cell'; // Reset class
                }
            }

            // Center the piece in the 4x4 preview grid
            const offsetX = Math.floor((4 - nextShape[0].length) / 2);
            const offsetY = Math.floor((4 - nextShape.length) / 2);

            // Draw the next piece
            for (let y = 0; y < nextShape.length; y++) {
                for (let x = 0; x < nextShape[y].length; x++) {
                    if (nextShape[y][x]) { // If it's a block
                        const cell = document.getElementById(`next-cell-${y + offsetY}-${x + offsetX}`);
                        cell.className = 'cell tetromino ' + nextPieceType; // Add tetromino class
                    }
                }
            }
        }

        /**
         * Draws the entire game grid, including locked blocks.
         */
        function drawGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = document.getElementById(`cell-${y}-${x}`);
                    cell.className = 'cell'; // Reset class
                    if (grid[y][x]) { // If a block is locked here
                        cell.className = 'cell tetromino ' + grid[y][x]; // Add its type class
                    }
                }
            }
        }

        /**
         * Draws the current moving piece on top of the existing grid.
         */
        function drawPiece() {
            drawGrid(); // First draw the underlying grid

            if (!currentPiece.shape) return; // No piece to draw

            // Draw the current piece
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) { // If it's a block of the current piece
                        const gridY = currentPiece.position.y + y;
                        const gridX = currentPiece.position.x + x;

                        // Only draw if within bounds (pieces can start above the grid)
                        if (gridY >= 0 && gridY < GRID_HEIGHT && gridX >= 0 && gridX < GRID_WIDTH) {
                            const cell = document.getElementById(`cell-${gridY}-${gridX}`);
                            // Add 'tetromino-fall' for a subtle animation
                            cell.className = 'cell tetromino ' + currentPiece.type + ' tetromino-fall';
                        }
                    }
                }
            }
        }

        /**
         * Checks if a potential move (with given offset and optional rotated shape) is valid.
         * @param {number} offsetX - Horizontal offset.
         * @param {number} offsetY - Vertical offset.
         * @param {Array<Array<number>>} [rotatedShape=null] - Optional, the shape after rotation.
         * @returns {boolean} True if the move is valid, false otherwise.
         */
        function isValidMove(offsetX, offsetY, rotatedShape = null) {
            const shape = rotatedShape || currentPiece.shape;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) { // If it's a block within the piece
                        const gridY = currentPiece.position.y + y + offsetY;
                        const gridX = currentPiece.position.x + x + offsetX;

                        // Check horizontal bounds
                        if (gridX < 0 || gridX >= GRID_WIDTH) {
                            return false;
                        }

                        // Check vertical bounds (allow piece to start above grid, but not go below)
                        if (gridY >= GRID_HEIGHT) {
                            return false;
                        }

                        // Check for collision with existing locked blocks (only if within grid bounds)
                        if (gridY >= 0 && grid[gridY][gridX]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        /**
         * Rotates the current piece 90 degrees clockwise. Includes basic wall kick.
         */
        function rotatePiece() {
            if (currentPiece.type === 'O') return; // O piece doesn't rotate

            const rows = currentPiece.shape.length;
            const cols = currentPiece.shape[0].length;
            const rotated = Array(cols).fill().map(() => Array(rows).fill(0));

            // Perform 90-degree clockwise rotation
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    rotated[x][rows - 1 - y] = currentPiece.shape[y][x];
                }
            }

            // Simplified Wall Kick Tests (real Tetris uses more complex SRS)
            // Try different offsets if rotation causes collision
            const kickTests = [
                [0, 0],   // No kick (if it fits as is)
                [-1, 0],  // Move left
                [1, 0],   // Move right
                [0, -1],  // Move up (useful for rotations against the floor or other blocks)
                [-2, 0],  // Move left twice
                [2, 0]    // Move right twice
            ];

            for (const [offsetX, offsetY] of kickTests) {
                if (isValidMove(offsetX, offsetY, rotated)) {
                    currentPiece.shape = rotated;
                    currentPiece.position.x += offsetX;
                    currentPiece.position.y += offsetY;
                    drawPiece();
                    return; // Rotation successful
                }
            }
        }

        /**
         * Moves the current piece by the given offset. Locks the piece if it can't move down.
         * @param {number} offsetX - Horizontal movement.
         * @param {number} offsetY - Vertical movement.
         * @returns {boolean} True if the piece moved, false otherwise.
         */
        function movePiece(offsetX, offsetY) {
            if (isValidMove(offsetX, offsetY)) {
                currentPiece.position.x += offsetX;
                currentPiece.position.y += offsetY;
                drawPiece();
                return true;
            }

            // If attempting to move down (offsetY === 1) and can't, lock the piece
            if (offsetY === 1) {
                lockPiece();
                checkLines();
                createNewPiece();

                // After creating a new piece, check if it immediately collides (game over condition)
                if (!isValidMove(0, 0)) {
                    gameOver();
                }
            }
            return false;
        }

        /**
         * Locks the current piece into the main game grid.
         */
        function lockPiece() {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const gridY = currentPiece.position.y + y;
                        const gridX = currentPiece.position.x + x;

                        // Only lock if within the visible grid (pieces can start above)
                        if (gridY >= 0 && gridY < GRID_HEIGHT && gridX >= 0 && gridX < GRID_WIDTH) {
                            grid[gridY][gridX] = currentPiece.type;
                        }
                    }
                }
            }
        }

        /**
         * Checks for and clears any completed lines, updates score, level, and lines.
         */
        function checkLines() {
            let linesCleared = 0;
            const oldLevel = level;

            for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                // If every cell in the row is not empty (0)
                if (grid[y].every(cell => cell !== 0)) {
                    linesCleared++;

                    // Add a temporary line clear animation overlay
                    const lineClear = document.createElement('div');
                    lineClear.className = 'line-clear';
                    lineClear.style.top = `${y * (gameGrid.clientHeight / GRID_HEIGHT)}px`; // Position it correctly
                    gameGrid.appendChild(lineClear);

                    // Remove the animation element after its duration
                    setTimeout(() => {
                        lineClear.remove();
                    }, 500);

                    // Remove the cleared row and add a new empty row at the top
                    grid.splice(y, 1);
                    grid.unshift(Array(GRID_WIDTH).fill(0));
                    y++; // Re-check the same row index, as all rows shifted down
                }
            }

            if (linesCleared > 0) {
                // Calculate score based on number of lines cleared and current level
                const points = SCORE_VALUES[linesCleared] * level;
                score += points;
                lines += linesCleared;
                level = Math.floor(lines / LINES_PER_LEVEL) + 1; // Increase level every LINES_PER_LEVEL lines

                updateScore();

                if (level !== oldLevel) {
                    updateGameSpeed(); // Adjust speed if level changed
                }

                drawGrid(); // Redraw grid after lines are cleared
            }
        }

        /**
         * Updates the score, level, and lines displayed on the UI.
         */
        function updateScore() {
            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesElement.textContent = lines;
        }

        /**
         * Adjusts the game interval speed based on the current level.
         */
        function updateGameSpeed() {
            clearInterval(gameInterval); // Clear existing interval
            const speed = Math.max(MIN_SPEED, INITIAL_SPEED - (level - 1) * SPEED_DECREMENT);
            gameInterval = setInterval(gameLoop, speed); // Set new interval
        }

        /**
         * The main game loop function, called repeatedly by setInterval.
         */
        function gameLoop() {
            if (!isPaused) {
                movePiece(0, 1); // Attempt to move piece down by one
            }
        }

        /**
         * Shows the game over modal and displays the final score.
         */
        function showGameOver() {
            finalScoreElement.textContent = score;
            gameOverModal.classList.add('active');
            playerNameInput.focus(); // Focus the input for player name
            startBtn.disabled = true; // Disable main Start button while modal is active
            // REMOVED: resetBtn.disabled = true; // No longer disable reset btn here
        }

        /**
         * Hides the game over modal and clears the player name input.
         * MODIFIED: Re-enables main game buttons that were disabled by showGameOver.
         */
        function hideGameOver() {
            gameOverModal.classList.remove('active');
            playerNameInput.value = ''; // Clear player name input for next game
            startBtn.disabled = false; // Re-enable main Start button
            resetBtn.disabled = false; // Re-enable main Reset button
        }

        /**
         * Handles the game over condition, stopping the game and showing the modal.
         */
        function gameOver() {
            clearInterval(gameInterval);
            gameStarted = false;
            startBtn.disabled = false; // Enable start button so user can restart from main UI
            resetBtn.disabled = false; // Ensure reset button is enabled
            pauseBtn.disabled = true;
            pauseBtn.innerHTML = '<i data-feather="pause" class="mr-2"></i>Pause';
            feather.replace(); // Re-render feather icon

            showGameOver();
        }

        /**
         * Starts a new game or restarts if already playing.
         */
        function startGame() {
            if (!gameStarted) {
                // Reset all game state variables
                grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
                score = 0;
                level = 1;
                lines = 0;
                updateScore();

                drawGrid(); // Clear the visual grid

                nextPieceType = getRandomPieceType(); // Get first next piece
                createNewPiece(); // Create the initial current piece
                drawPiece(); // Draw the initial piece

                updateGameSpeed(); // Start game loop

                gameStarted = true;
                startBtn.disabled = true; // Disable start button during play
                pauseBtn.disabled = false; // Enable pause button
                resetBtn.disabled = false; // Ensure reset button is enabled

                hideGameOver(); // Ensure game over modal is hidden
            } else if (isPaused) {
                // If game is started and paused, just resume it
                pauseGame();
            }

            // Ensure music is playing when game starts/resumes, unless explicitly muted
            if (!isMusicMuted && bgMusic.paused) {
                const playPromise = bgMusic.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Music play failed on game start/resume:", error);
                        // No need for a global listener here, as user just clicked 'start'
                    });
                }
            }
        }

        /**
         * Toggles game pause state.
         */
        function pauseGame() {
            // Can only pause/resume if the game has started OR if the game is already paused
            if (!gameStarted) return; // Only allow pause if game has started at least once

            isPaused = !isPaused;
            pauseBtn.innerHTML = isPaused
                ? '<i data-feather="play" class="mr-2"></i>Resume' // Change button text
                : '<i data-feather="pause" class="mr-2"></i>Pause';
            pauseOverlay.classList.toggle('hidden', !isPaused); // Show/hide pause overlay
            feather.replace(); // Re-render feather icon
        }

        /**
         * Resets the entire game to its initial state.
         */
        function resetGame() {
            clearInterval(gameInterval);
            gameStarted = false;
            isPaused = false;

            startBtn.disabled = false; // Enable start button
            pauseBtn.disabled = true;  // Disable pause button
            resetBtn.disabled = false; // Ensure reset button is enabled
            pauseBtn.innerHTML = '<i data-feather="pause" class="mr-2"></i>Pause';
            pauseOverlay.classList.add('hidden'); // Hide pause overlay
            feather.replace();

            grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
            drawGrid();

            score = 0;
            level = 1;
            lines = 0;
            updateScore();

            // Clear current piece and generate a new next piece for preview
            currentPiece.shape = null;
            currentPiece.type = null;
            currentPiece.position = { x: 0, y: 0 };
            nextPieceType = getRandomPieceType();
            updateNextPiecePreview();

            hideGameOver(); // Ensure game over modal is hidden
        }

        /**
         * Handles keyboard input for game controls.
         * @param {KeyboardEvent} e - The keyboard event object.
         */
        function handleKeyDown(e) {
            // 1. Prevent default browser actions for game-critical keys
            // ADDED 'm' and 'M' to preventableKeys
            const preventableKeys = ['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' ', 'p', 'P', 'r', 'R', 'Enter', 'a', 'A', 's', 'S', 'd', 'D', 'w', 'W', 'm', 'M'];
            if (preventableKeys.includes(e.key)) {
                e.preventDefault();
            }

            // 2. Handle 'M' key for music toggle (always works)
            if (e.key === 'm' || e.key === 'M') {
                toggleMusicMute();
                return; // Consume the event and exit
            }

            // 3. Handle 'R' key for reset (always works)
            if (e.key === 'r' || e.key === 'R') {
                resetGame();
                return; // Consume the event and exit
            }

            // 4. Handle 'Enter' key for start/resume
            // This should NOT trigger if the game over modal is currently active,
            // as it might conflict with saving score/playing again via modal buttons.
            if (e.key === 'Enter' && !gameOverModal.classList.contains('active')) {
                if (!gameStarted) { // If game is not started (initial state or after reset)
                    startGame();
                } else if (gameStarted && isPaused) { // If game is running but paused
                    pauseGame(); // Resumes the game
                }
                // If game is running and not paused, 'Enter' does nothing.
                return; // Consume the event and exit
            }

            // 5. Handle 'P' key for pause/resume toggle (only works if game has started)
            if (e.key === 'p' || e.key === 'P') {
                 // MODIFIED: Ensure game has started before allowing pause/resume
                if(gameStarted) {
                    pauseGame();
                }
                return; // Consume the event and exit
            }


            // 6. For all other game controls (movement, rotation, hard drop):
            // They only work if the game is started AND NOT paused AND the game over modal is NOT active.
            if (!gameStarted || isPaused || gameOverModal.classList.contains('active')) {
                return; // Exit if game not started, or paused, or game over modal is active
            }

            // 7. Existing game control logic (A, D, S, W, Space)
            switch (e.key) {
                case 'a': case 'A': case 'ArrowLeft':
                    movePiece(-1, 0);
                    break;
                case 'd': case 'D': case 'ArrowRight':
                    movePiece(1, 0);
                    break;
                case 's': case 'S': case 'ArrowDown':
                    movePiece(0, 1);
                    break;
                case 'w': case 'W': case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ': // Space bar for hard drop
                    while (movePiece(0, 1)) {} // Keep dropping until it hits something
                    break;
            }
        }


        // --- NEW HIGH SCORE FUNCTIONS ---

        const LOCAL_STORAGE_KEY = 'neonTetrisHighScores';
        const MAX_HIGH_SCORES = 5; // Display top 5 scores

        /**
         * Loads high scores from localStorage.
         * @returns {Array<Object>} An array of score objects {name: string, score: number}.
         */
        function loadHighScores() {
            const scoresString = localStorage.getItem(LOCAL_STORAGE_KEY);
            return scoresString ? JSON.parse(scoresString) : [];
        }

        /**
         * Saves a list of high scores to localStorage.
         * @param {Array<Object>} scores - The array of score objects to save.
         */
        function saveHighScores(scores) {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores));
        }

        /**
         * Displays the current high scores on the UI.
         */
        function displayHighScores() {
            const scores = loadHighScores();
            highScoresList.innerHTML = ''; // Clear existing list items

            if (scores.length === 0) {
                const li = document.createElement('li');
                li.className = 'flex justify-between text-slate-400';
                li.innerHTML = '<span>No scores yet.</span>';
                highScoresList.appendChild(li);
            } else {
                scores.forEach((entry, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center';
                    li.innerHTML = `
                        <span class="text-slate-300 font-mono">${index + 1}. ${entry.name.substring(0, 10)}</span>
                        <span class="text-neon-green glow-text">${entry.score}</span>
                    `;
                    highScoresList.appendChild(li);
                });
            }
            feather.replace(); // Ensure any new feather icons in the list are rendered
        }

        /**
         * Saves the current game's score as a high score.
         */
        function saveHighScore() {
            const playerName = playerNameInput.value.trim();
            const currentScores = loadHighScores();

            const newScoreEntry = {
                name: playerName.length > 0 ? playerName : 'Anonymous',
                score: score // 'score' is a global game state variable
            };

            currentScores.push(newScoreEntry);

            // Sort by score descending (highest score first)
            currentScores.sort((a, b) => b.score - a.score);

            // Keep only the top N scores
            const topScores = currentScores.slice(0, MAX_HIGH_SCORES);

            saveHighScores(topScores); // Save the updated list to localStorage

            displayHighScores(); // Update the displayed list on the page

            resetGame(); // Reset the game after saving score
            hideGameOver(); // Make sure modal is hidden
        }
        // --- END NEW HIGH SCORE FUNCTIONS ---

        // --- NEW MUSIC FUNCTIONS ---

        /**
         * Updates the mute button icon based on the current music muted state.
         * Corrected to properly handle Feather Icons dynamic updates.
         */
        function updateMuteButtonIcon() {
            // Find the currently rendered SVG icon inside the button.
            // Feather Icons replaces the <i> tag with an <svg> element.
            let currentSvg = muteToggleBtn.querySelector('svg');

            // Create a new temporary <i> element to hold the desired 'data-feather' attribute.
            const tempIconPlaceholder = document.createElement('i');
            tempIconPlaceholder.classList.add('mr-2'); // Re-add any necessary classes like 'mr-2'

            // Set the correct 'data-feather' attribute based on the music muted state.
            if (isMusicMuted) {
                tempIconPlaceholder.setAttribute('data-feather', 'volume-x'); // Icon for muted
            } else {
                tempIconPlaceholder.setAttribute('data-feather', 'volume-2'); // Icon for unmuted
            }

            // If an old SVG icon exists, replace it with our new temporary <i> placeholder.
            // This ensures the icon's position within the button is maintained.
            if (currentSvg) {
                currentSvg.replaceWith(tempIconPlaceholder);
            } else {
                // Fallback: If for some reason no SVG is found (e.g., initial load before feather.replace() runs,
                // or if button structure changes), prepend the new <i> tag.
                muteToggleBtn.prepend(tempIconPlaceholder);
            }

            // Now, tell Feather Icons to process this specific newly inserted <i> tag.
            // It will remove 'tempIconPlaceholder' and insert the appropriate new SVG.
            feather.replace({ target: tempIconPlaceholder });
        }

        /**
         * Toggles the background music mute state.
         */
        function toggleMusicMute() {
            isMusicMuted = !isMusicMuted;
            bgMusic.muted = isMusicMuted;
            updateMuteButtonIcon(); // Update button icon
            localStorage.setItem('isMusicMuted', isMusicMuted); // Save state for persistence

            // If unmuting and music is paused (e.g., due to autoplay block), try to play
            if (!isMusicMuted && bgMusic.paused) {
                const playPromise = bgMusic.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Music play failed on unmute, user interaction needed:", error);
                        // This case is rare if the initial document listener handles it, but good fallback.
                    });
                }
            }
        }

        /**
         * Initializes music state from localStorage and attempts to play.
         * Handles browser autoplay policies.
         */
        function initMusic() {
            const storedMuted = localStorage.getItem('isMusicMuted');
            isMusicMuted = storedMuted === 'true'; // localStorage stores strings, convert to boolean

            bgMusic.muted = isMusicMuted;
            updateMuteButtonIcon(); // Set initial icon based on loaded state

            // Attempt to play on load. This might be blocked by browsers if not muted.
            const playPromise = bgMusic.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Autoplay started successfully (e.g., because it was muted, or user had previously interacted)
                }).catch(error => {
                    // Autoplay was prevented. User interaction required.
                    console.log("Autoplay blocked. User interaction needed to start music.");

                    // Add a one-time listener for the first user interaction (click or keydown)
                    const startMusicOnInteraction = () => {
                        bgMusic.play().catch(e => console.warn("Music play failed after user interaction:", e));
                        document.removeEventListener('click', startMusicOnInteraction);
                        document.removeEventListener('keydown', startMusicOnInteraction);
                    };
                    document.addEventListener('click', startMusicOnInteraction);
                    document.addEventListener('keydown', startMusicOnInteraction);
                });
            }
        }
        // --- END NEW MUSIC FUNCTIONS ---


        // Event listeners
        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', pauseGame);
        resetBtn.addEventListener('click', resetGame);
        document.addEventListener('keydown', handleKeyDown);
        saveScoreBtn.addEventListener('click', saveHighScore);
        playAgainBtn.addEventListener('click', startGame);

        // NEW: Music mute toggle event listener (using the updated muteToggleBtn reference)
        muteToggleBtn.addEventListener('click', toggleMusicMute);

        // Initialize the game when the script loads
        initGrid();
        initNextPieceGrid();
        nextPieceType = getRandomPieceType(); // Get the very first next piece
        updateNextPiecePreview(); // Display it
        displayHighScores(); // NEW: Display high scores on load
        initMusic(); // NEW: Initialize background music
    </script>
</body>
</html>